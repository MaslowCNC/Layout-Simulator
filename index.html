<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Drawing</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="myCanvas" width="1000" height="900"></canvas>
    <script>
        var canvas = document.getElementById('myCanvas');
        var tp = canvas.getContext('2d');
        var tpBbox = { min: { x: Infinity, y: Infinity }, max: { x: -Infinity, y: -Infinity } };
        var bboxIsSet = false;

        var tlX = 0;
        var tlY = 2000;
        var trX = 3000; 
        var trY = 2000;
        var blX = 0;
        var blY = 0;
        var brX = 3000;
        var brY = 0;

        var scale = .25;
        var panX = 0;
        var panY = 0;
        var isPanning = false;
        var startX, startY;

        //Shifts 0,0 to be the center of the canvas and scales the points for zooming
        function projection(point) {
            return { x: point.x * scale + canvas.width / 2 + panX, y: point.y * scale + canvas.height / 2 + panY };
        }

        //This is the inverse of projection, it shifts a point from the canvas to the original coordinate system
        function inverseProjection(point) {
            return { x: (point.x - canvas.width / 2 - panX) / scale, y: (point.y - canvas.height / 2 - panY) / scale };
        }

        function draw() {
            tp.clearRect(0, 0, canvas.width, canvas.height);
            drawMachineBounds();
            drawMachineBelts();
        }

        var drawMachineBounds = function() {
            var woodWidth = 2438;
            var woodHeight = 2438 / 2;

            const p0 = projection({ x: -woodWidth / 2, y: -woodHeight / 2, z: 0 });
            const p1 = projection({ x: woodWidth / 2, y: -woodHeight / 2, z: 0 });
            const p2 = projection({ x: woodWidth / 2, y: woodHeight / 2, z: 0 });
            const p3 = projection({ x: -woodWidth / 2, y: woodHeight / 2, z: 0 });

            tpBbox.min.x = Math.min(tpBbox.min.x, p0.x);
            tpBbox.min.y = Math.min(tpBbox.min.y, p0.y);
            tpBbox.max.x = Math.max(tpBbox.max.x, p2.x);
            tpBbox.max.y = Math.max(tpBbox.max.y, p2.y);
            bboxIsSet = true;

            tp.beginPath();
            tp.moveTo(p0.x, p0.y);
            tp.lineTo(p1.x, p1.y);
            tp.lineTo(p2.x, p2.y);
            tp.lineTo(p3.x, p3.y);
            tp.lineTo(p0.x, p0.y);
            tp.strokeStyle = "green";
            tp.stroke();
        }

        var drawMachineBelts = function() {

            const tl = projection({x: tlX - trX/2, y: tlY/2, z: 0});
            const tr = projection({x: trX/2, y: trY/2, z: 0});
            const bl = projection({x: blX - brX/2, y: blY - tlY/2, z: 0});
            const br = projection({x: brX/2, y: brY - trY/2, z: 0});

            tpBbox.min.x = Math.min(tpBbox.min.x, bl.x);
            tpBbox.min.y = Math.min(tpBbox.min.y, bl.y);
            tpBbox.max.x = Math.max(tpBbox.max.x, tr.x);
            tpBbox.max.y = Math.max(tpBbox.max.y, tr.y);

            //Find the center
            let c = projection({x: 0, y: 0, z: 0});

            tp.beginPath();
            tp.strokeStyle = "grey";
            tp.moveTo(c.x, c.y);
            tp.lineTo(tl.x, tl.y);
            tp.moveTo(c.x, c.y);
            tp.lineTo(tr.x, tr.y);
            tp.moveTo(c.x, c.y);
            tp.lineTo(bl.x, bl.y);
            tp.moveTo(c.x, c.y);
            tp.lineTo(br.x, br.y);
            tp.stroke();

            tp.fillStyle = "black";
            tp.beginPath();
            tp.arc(tl.x, tl.y, 10, 0, 2 * Math.PI);
            tp.closePath();
            tp.fill();
            tp.beginPath();
            tp.arc(tr.x, tr.y, 10, 0, 2 * Math.PI);
            tp.closePath();
            tp.fill();
            tp.beginPath();
            tp.arc(br.x, br.y, 10, 0, 2 * Math.PI);
            tp.closePath();
            tp.fill();
            tp.beginPath();
            tp.arc(bl.x, bl.y, 10, 0, 2 * Math.PI);
            tp.closePath();
            tp.fill();

            const squareSize = 50* scale;

            //drawARect(tl.x, tl.y, squareSize, computePositionGradient(0, 0, tl, tr, bl, br));

            var i = bl.x;
            var j = bl.y;
            while (i < tr.x) {
                while (j < tr.y) {
                    drawARect(i, j, squareSize, computePositionGradient(i, j, tl, tr, bl, br));
                    j = j + squareSize;
                }
                j = bl.y;
                i = i + squareSize;
            }
        }

        var checkMinBeltLength = function(x1, y1, x2, y2) {

            const dist = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));

            if (dist < 1200) {
                return 1 - dist / 1200;
            } else {
                return 0;
            }
        }

        var computePositionGradient = function(x, y, tl, tr, bl, br) {
            var opacity = 0;

            let posI = inverseProjection({x: x, y: y});
            let tlI = inverseProjection(tl);
            let trI = inverseProjection(tr);
            let blI = inverseProjection(bl);
            let brI = inverseProjection(br);


            opacity = opacity + checkMinBeltLength(posI.x, posI.y, tlI.x, tlI.y);
            opacity = opacity + checkMinBeltLength(posI.x, posI.y, trI.x, trI.y);
            opacity = opacity + checkMinBeltLength(posI.x, posI.y, blI.x, blI.y);
            opacity = opacity + checkMinBeltLength(posI.x, posI.y, brI.x, brI.y);

            opacity = Math.max(opacity, computeTension(posI.x, posI.y, tlI, trI, blI, brI));

            return opacity;
        }

        var computeTension = function(x,y, tl, tr, bl, br){
            const A = Math.atan((y-tl.y)/(tr.x - x));
            const B = Math.atan((y-tl.y)/(x-tl.x));

            const T1 = 1 / (Math.cos(A) * Math.sin(B) / Math.cos(B) + Math.sin(A));
            const T2 = 1 / (Math.cos(B) * Math.sin(A) / Math.cos(A) + Math.sin(B));

            const T1Scaled = T1/-3;
            const T2Scaled = T2/-3; //This is some arbitrary scaling to make it look right in terms of color

            const max = Math.max(T1Scaled, T2Scaled);

            if(max > .15){
                return max;
            }
            else{
                return 0;
            }
        }

        // License: MIT - https://opensource.org/licenses/MIT
        // Author: Michele Locati <michele@locati.it>
        // Source: https://gist.github.com/mlocati/7210513
        var perc2color = function(perc) {
            var r, g, b = 0;
            if(perc < 50) {
                r = 255;
                g = Math.round(5.1 * perc);
            }
            else {
                g = 255;
                r = Math.round(510 - 5.10 * perc);
            }
            var h = r * 0x10000 + g * 0x100 + b * 0x1;

            //onsole.log(r + " " + g + " " + b)
            return "rgba("+r+", "+g+", "+b+", .3)";//'#' + ('000000' + h.toString(16)).slice(-6);
        }

        var drawARect = function(x, y, size, opacity) {
            tp.beginPath();
            tp.fillStyle = perc2color(100 - 100 * opacity);
            tp.rect(x - size / 2, y - size / 2, size, size);
            tp.fill();
        }

        canvas.addEventListener('mousedown', function(e) {
            isPanning = true;
            startX = e.clientX - panX;
            startY = e.clientY - panY;
        });

        canvas.addEventListener('mousemove', function(e) {
            if (isPanning) {
                panX = e.clientX - startX;
                panY = e.clientY - startY;
                draw();
            }
        });

        canvas.addEventListener('mouseup', function() {
            isPanning = false;
        });

        canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            var scaleAmount = e.deltaY * -0.01;
            scale += scaleAmount;
            scale = Math.min(Math.max(.125, scale), 4);
            draw();
        });

        draw();
    </script>
</body>
</html>